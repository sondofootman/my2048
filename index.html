<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes appear {
            0% {
                opacity: 0;
                transform: scale(0.5);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes merge {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1);
            }
        }

        .tile {
            transition: all 0.15s ease-in-out;
            animation: appear 0.15s ease-in-out;
        }

        .tile-merged {
            animation: merge 0.15s ease-in-out;
            z-index: 10;
        }

        .game-container {
            perspective: 1000px;
        }

        .grid {
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.1);
        }

        .game-overlay {
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .tile-2 { background-color: #eee4da; }
        .tile-4 { background-color: #ede0c8; }
        .tile-8 { background-color: #f2b179; color: white; }
        .tile-16 { background-color: #f59563; color: white; }
        .tile-32 { background-color: #f67c5f; color: white; }
        .tile-64 { background-color: #f65e3b; color: white; }
        .tile-128 { background-color: #edcf72; color: white; font-size: 2.5rem; }
        .tile-256 { background-color: #edcc61; color: white; font-size: 2.5rem; }
        .tile-512 { background-color: #edc850; color: white; font-size: 2.5rem; }
        .tile-1024 { background-color: #edc53f; color: white; font-size: 2rem; }
        .tile-2048 { background-color: #edc22e; color: white; font-size: 2rem; }
        .tile-super { background-color: #3c3a32; color: white; font-size: 1.8rem; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">
    <div class="game-container relative">
        <div class="mb-6 text-center">
            <h1 class="text-5xl font-bold text-gray-700 mb-2">2048</h1>
            <div class="flex justify-center gap-8">
                <div class="bg-gray-200 rounded px-4 py-2">
                    <span class="text-gray-600">Score:</span>
                    <span id="score" class="font-bold ml-2">0</span>
                </div>
                <button id="new-game" class="bg-orange-500 hover:bg-orange-600 text-white font-bold px-4 py-2 rounded transition">
                    New Game
                </button>
            </div>
        </div>

        <div class="grid grid-cols-4 gap-3 p-3 bg-gray-300 rounded-lg relative">
            <!-- Empty grid cells -->
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>
            <div class="w-20 h-20 bg-gray-200 rounded-md"></div>

            <!-- Tiles will be dynamically added here -->
            <div id="tiles-container" class="absolute inset-0 grid grid-cols-4 gap-3 p-3 pointer-events-none"></div>
        </div>

        <div id="game-over" class="game-overlay absolute inset-0 bg-black bg-opacity-50 rounded-lg flex flex-col items-center justify-center opacity-0 pointer-events-none">
            <div class="bg-white p-6 rounded-lg text-center">
                <h2 class="text-2xl font-bold mb-4">Game Over!</h2>
                <p class="mb-4">Your score: <span id="final-score" class="font-bold">0</span></p>
                <button id="try-again" class="bg-orange-500 hover:bg-orange-600 text-white font-bold px-4 py-2 rounded transition">
                    Try Again
                </button>
            </div>
        </div>

        <div id="win-message" class="game-overlay absolute inset-0 bg-black bg-opacity-50 rounded-lg flex flex-col items-center justify-center opacity-0 pointer-events-none">
            <div class="bg-white p-6 rounded-lg text-center">
                <h2 class="text-2xl font-bold mb-4">You Win!</h2>
                <p class="mb-4">You reached 2048! Keep going?</p>
                <div class="flex gap-4 justify-center">
                    <button id="continue-game" class="bg-green-500 hover:bg-green-600 text-white font-bold px-4 py-2 rounded transition">
                        Continue
                    </button>
                    <button id="new-game-win" class="bg-orange-500 hover:bg-orange-600 text-white font-bold px-4 py-2 rounded transition">
                        New Game
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="mt-8 text-gray-600 text-center max-w-md">
        <p class="mb-2">Use arrow keys or swipe to move the tiles.</p>
        <p>When two tiles with the same number touch, they merge into one!</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const GRID_SIZE = 4;
            let board = createEmptyBoard();
            let score = 0;
            let gameOver = false;
            let won = false;
            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;

            // DOM elements
            const tilesContainer = document.getElementById('tiles-container');
            const scoreElement = document.getElementById('score');
            const gameOverElement = document.getElementById('game-over');
            const finalScoreElement = document.getElementById('final-score');
            const tryAgainButton = document.getElementById('try-again');
            const newGameButton = document.getElementById('new-game');
            const winMessageElement = document.getElementById('win-message');
            const continueGameButton = document.getElementById('continue-game');
            const newGameWinButton = document.getElementById('new-game-win');

            // Initialize game
            startGame();

            // Event listeners
            document.addEventListener('keydown', handleKeyPress);
            newGameButton.addEventListener('click', startGame);
            tryAgainButton.addEventListener('click', startGame);
            continueGameButton.addEventListener('click', () => {
                winMessageElement.classList.add('opacity-0', 'pointer-events-none');
                won = true;
            });
            newGameWinButton.addEventListener('click', startGame);

            // Touch events for mobile
            document.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, false);

            document.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].clientX;
                touchEndY = e.changedTouches[0].clientY;
                handleSwipe();
            }, false);

            function createEmptyBoard() {
                return Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            }

            function startGame() {
                board = createEmptyBoard();
                score = 0;
                gameOver = false;
                won = false;
                updateScore();
                clearTiles();
                addRandomTile();
                addRandomTile();
                renderBoard();
                gameOverElement.classList.add('opacity-0', 'pointer-events-none');
                winMessageElement.classList.add('opacity-0', 'pointer-events-none');
            }

            function clearTiles() {
                tilesContainer.innerHTML = '';
            }

            function updateScore() {
                scoreElement.textContent = score;
            }

            function addRandomTile() {
                const emptyCells = [];
                
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (board[row][col] === 0) {
                            emptyCells.push({ row, col });
                        }
                    }
                }

                if (emptyCells.length > 0) {
                    const { row, col } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    board[row][col] = Math.random() < 0.9 ? 2 : 4;
                }
            }

            function renderBoard() {
                clearTiles();
                
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const value = board[row][col];
                        if (value !== 0) {
                            const tile = document.createElement('div');
                            tile.className = `tile absolute flex items-center justify-center w-20 h-20 rounded-md font-bold text-3xl`;
                            tile.classList.add(`tile-${value}`);
                            if (value > 2048) {
                                tile.classList.add('tile-super');
                            }
                            tile.textContent = value;
                            tile.style.left = `${col * (80 + 12)}px`;
                            tile.style.top = `${row * (80 + 12)}px`;
                            tilesContainer.appendChild(tile);
                        }
                    }
                }
            }

            function handleKeyPress(e) {
                if (gameOver) return;
                
                let moved = false;
                
                switch (e.key) {
                    case 'ArrowUp':
                        moved = moveTilesUp();
                        break;
                    case 'ArrowDown':
                        moved = moveTilesDown();
                        break;
                    case 'ArrowLeft':
                        moved = moveTilesLeft();
                        break;
                    case 'ArrowRight':
                        moved = moveTilesRight();
                        break;
                    default:
                        return;
                }

                if (moved) {
                    addRandomTile();
                    renderBoard();
                    
                    if (isGameOver()) {
                        gameOver = true;
                        finalScoreElement.textContent = score;
                        gameOverElement.classList.remove('opacity-0', 'pointer-events-none');
                    }
                }
            }

            function handleSwipe() {
                if (gameOver) return;
                
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;
                const absDx = Math.abs(dx);
                const absDy = Math.abs(dy);
                
                if (Math.max(absDx, absDy) < 30) return; // Minimum swipe distance
                
                let moved = false;
                
                if (absDx > absDy) {
                    // Horizontal swipe
                    if (dx > 0) {
                        moved = moveTilesRight();
                    } else {
                        moved = moveTilesLeft();
                    }
                } else {
                    // Vertical swipe
                    if (dy > 0) {
                        moved = moveTilesDown();
                    } else {
                        moved = moveTilesUp();
                    }
                }

                if (moved) {
                    addRandomTile();
                    renderBoard();
                    
                    if (isGameOver()) {
                        gameOver = true;
                        finalScoreElement.textContent = score;
                        gameOverElement.classList.remove('opacity-0', 'pointer-events-none');
                    }
                }
            }

            function moveTilesUp() {
                let moved = false;
                
                for (let col = 0; col < GRID_SIZE; col++) {
                    for (let row = 1; row < GRID_SIZE; row++) {
                        if (board[row][col] !== 0) {
                            let currentRow = row;
                            
                            while (currentRow > 0) {
                                if (board[currentRow - 1][col] === 0) {
                                    // Move tile to empty space
                                    board[currentRow - 1][col] = board[currentRow][col];
                                    board[currentRow][col] = 0;
                                    currentRow--;
                                    moved = true;
                                } else if (board[currentRow - 1][col] === board[currentRow][col]) {
                                    // Merge tiles
                                    board[currentRow - 1][col] *= 2;
                                    score += board[currentRow - 1][col];
                                    board[currentRow][col] = 0;
                                    
                                    // Check for win condition
                                    if (board[currentRow - 1][col] === 2048 && !won) {
                                        won = true;
                                        winMessageElement.classList.remove('opacity-0', 'pointer-events-none');
                                    }
                                    
                                    moved = true;
                                    break;
                                } else {
                                    break;
                                }
                            }
                        }
                    }
                }
                
                if (moved) updateScore();
                return moved;
            }

            function moveTilesDown() {
                let moved = false;
                
                for (let col = 0; col < GRID_SIZE; col++) {
                    for (let row = GRID_SIZE - 2; row >= 0; row--) {
                        if (board[row][col] !== 0) {
                            let currentRow = row;
                            
                            while (currentRow < GRID_SIZE - 1) {
                                if (board[currentRow + 1][col] === 0) {
                                    // Move tile to empty space
                                    board[currentRow + 1][col] = board[currentRow][col];
                                    board[currentRow][col] = 0;
                                    currentRow++;
                                    moved = true;
                                } else if (board[currentRow + 1][col] === board[currentRow][col]) {
                                    // Merge tiles
                                    board[currentRow + 1][col] *= 2;
                                    score += board[currentRow + 1][col];
                                    board[currentRow][col] = 0;
                                    
                                    // Check for win condition
                                    if (board[currentRow + 1][col] === 2048 && !won) {
                                        won = true;
                                        winMessageElement.classList.remove('opacity-0', 'pointer-events-none');
                                    }
                                    
                                    moved = true;
                                    break;
                                } else {
                                    break;
                                }
                            }
                        }
                    }
                }
                
                if (moved) updateScore();
                return moved;
            }

            function moveTilesLeft() {
                let moved = false;
                
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 1; col < GRID_SIZE; col++) {
                        if (board[row][col] !== 0) {
                            let currentCol = col;
                            
                            while (currentCol > 0) {
                                if (board[row][currentCol - 1] === 0) {
                                    // Move tile to empty space
                                    board[row][currentCol - 1] = board[row][currentCol];
                                    board[row][currentCol] = 0;
                                    currentCol--;
                                    moved = true;
                                } else if (board[row][currentCol - 1] === board[row][currentCol]) {
                                    // Merge tiles
                                    board[row][currentCol - 1] *= 2;
                                    score += board[row][currentCol - 1];
                                    board[row][currentCol] = 0;
                                    
                                    // Check for win condition
                                    if (board[row][currentCol - 1] === 2048 && !won) {
                                        won = true;
                                        winMessageElement.classList.remove('opacity-0', 'pointer-events-none');
                                    }
                                    
                                    moved = true;
                                    break;
                                } else {
                                    break;
                                }
                            }
                        }
                    }
                }
                
                if (moved) updateScore();
                return moved;
            }

            function moveTilesRight() {
                let moved = false;
                
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = GRID_SIZE - 2; col >= 0; col--) {
                        if (board[row][col] !== 0) {
                            let currentCol = col;
                            
                            while (currentCol < GRID_SIZE - 1) {
                                if (board[row][currentCol + 1] === 0) {
                                    // Move tile to empty space
                                    board[row][currentCol + 1] = board[row][currentCol];
                                    board[row][currentCol] = 0;
                                    currentCol++;
                                    moved = true;
                                } else if (board[row][currentCol + 1] === board[row][currentCol]) {
                                    // Merge tiles
                                    board[row][currentCol + 1] *= 2;
                                    score += board[row][currentCol + 1];
                                    board[row][currentCol] = 0;
                                    
                                    // Check for win condition
                                    if (board[row][currentCol + 1] === 2048 && !won) {
                                        won = true;
                                        winMessageElement.classList.remove('opacity-0', 'pointer-events-none');
                                    }
                                    
                                    moved = true;
                                    break;
                                } else {
                                    break;
                                }
                            }
                        }
                    }
                }
                
                if (moved) updateScore();
                return moved;
            }

            function isGameOver() {
                // Check for empty cells
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (board[row][col] === 0) {
                            return false;
                        }
                    }
                }
                
                // Check for possible merges
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const value = board[row][col];
                        
                        // Check right neighbor
                        if (col < GRID_SIZE - 1 && board[row][col + 1] === value) {
                            return false;
                        }
                        
                        // Check bottom neighbor
                        if (row < GRID_SIZE - 1 && board[row + 1][col] === value) {
                            return false;
                        }
                    }
                }
                
                return true;
            }
        });
    </script>
</body>
</html>