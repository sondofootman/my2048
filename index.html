<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2048 Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .game-container {
      max-width: 450px;
      width: 100%;
      margin: 0 auto;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-gap: 10px;
      padding: 15px;
      background-color: #bbada0;
      border-radius: 6px;
      position: relative;
    }
    .cell {
      background-color: rgba(238, 228, 218, 0.35);
      border-radius: 3px;
      aspect-ratio: 1;
    }
    .tile {
      position: absolute;
      border-radius: 3px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 45px;
      font-weight: bold;
      transition: top 0.1s, left 0.1s;
      z-index: 10;
      width: 100px;
      height: 100px;
    }
    .tile-2 { background-color: #eee4da; color: #776e65; }
    .tile-4 { background-color: #ede0c8; color: #776e65; }
    .tile-8 { background-color: #f2b179; color: #f9f6f2; }
    .tile-16 { background-color: #f59563; color: #f9f6f2; }
    .tile-32 { background-color: #f67c5f; color: #f9f6f2; }
    .tile-64 { background-color: #f65e3b; color: #f9f6f2; }
    .tile-128 { background-color: #edcf72; color: #f9f6f2; font-size: 40px; }
    .tile-256 { background-color: #edcc61; color: #f9f6f2; font-size: 40px; }
    .tile-512 { background-color: #edc850; color: #f9f6f2; font-size: 40px; }
    .tile-1024 { background-color: #edc53f; color: #f9f6f2; font-size: 35px; }
    .tile-2048 { background-color: #edc22e; color: #f9f6f2; font-size: 35px; }
    .game-over {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(238, 228, 218, 0.73);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      z-index: 100;
      border-radius: 6px;
    }
    .game-over-text {
      font-size: 60px; font-weight: bold; color: #776e65;
      margin-bottom: 30px;
    }
    .new-tile {
      animation: appear 0.2s;
    }
    @keyframes appear {
      0% { opacity: 0; transform: scale(0); }
      100% { opacity: 1; transform: scale(1); }
    }
  </style>
</head>
<body class="bg-[#faf8ef] min-h-screen font-sans">
  <div class="container mx-auto py-10">
    <div class="game-container">
      <div class="flex justify-between items-center mb-5">
        <h1 class="text-6xl font-bold text-[#776e65]">2048</h1>
        <div class="flex gap-4">
          <div class="score-container bg-[#bbada0] text-white px-4 py-2 rounded text-center">
            <div class="text-sm uppercase font-bold">Score</div>
            <div id="score" class="text-2xl font-bold">0</div>
          </div>
          <div class="score-container bg-[#bbada0] text-white px-4 py-2 rounded text-center">
            <div class="text-sm uppercase font-bold">Best</div>
            <div id="high-score" class="text-2xl font-bold">0</div>
          </div>
          <button id="new-game" class="bg-[#8f7a66] text-white px-4 py-2 rounded font-bold hover:bg-[#9f8b77]">New Game</button>
        </div>
      </div>

      <p class="text-[#776e65] mb-5 text-lg">
        Join the numbers and get to the <strong>2048 tile!</strong><br/>
        Use <strong>arrow keys</strong> to move tiles.
      </p>

      <div class="grid" id="grid">
        <!-- 16 cells -->
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>

        <!-- Game over overlay -->
        <div id="game-over" class="game-over hidden">
          <div class="game-over-text">Game Over!</div>
          <button id="try-again" class="bg-[#8f7a66] text-white px-6 py-3 rounded font-bold hover:bg-[#9f8b77]">Try Again</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const GRID_SIZE = 4;
      let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      let score = 0;
      let highScore = localStorage.getItem("highScore") || 0;
      let gameOver = false;

      const gridElement = document.getElementById("grid");
      const scoreElement = document.getElementById("score");
      const highScoreElement = document.getElementById("high-score");
      const gameOverElement = document.getElementById("game-over");
      const newGameButton = document.getElementById("new-game");
      const tryAgainButton = document.getElementById("try-again");

      function initGame() {
        grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        score = 0;
        gameOver = false;
        updateScore();
        renderGrid();
        addRandomTile();
        addRandomTile();
        gameOverElement.classList.add("hidden");
      }
      if (window.Telegram.WebApp) {
  Telegram.WebApp.expand();
  Telegram.WebApp.ready();
}

      function renderGrid() {
        document.querySelectorAll(".tile").forEach(tile => tile.remove());
        for (let row = 0; row < GRID_SIZE; row++) {
          for (let col = 0; col < GRID_SIZE; col++) {
            const value = grid[row][col];
            if (value !== 0) {
              const tile = document.createElement("div");
              tile.className = `tile tile-${value} new-tile`;
              tile.textContent = value;
              tile.style.top = `${15 + row * 110}px`;
              tile.style.left = `${15 + col * 110}px`;
              gridElement.appendChild(tile);
              setTimeout(() => tile.classList.remove("new-tile"), 200);
            }
          }
        }
      }

      function updateScore() {
        scoreElement.textContent = score;
        if (score > highScore) {
          highScore = score;
          localStorage.setItem("highScore", highScore);
        }
        highScoreElement.textContent = highScore;
      }

      function addRandomTile() {
        const empty = [];
        for (let row = 0; row < GRID_SIZE; row++) {
          for (let col = 0; col < GRID_SIZE; col++) {
            if (grid[row][col] === 0) empty.push({ row, col });
          }
        }
        if (empty.length > 0) {
          const { row, col } = empty[Math.floor(Math.random() * empty.length)];
          grid[row][col] = Math.random() < 0.9 ? 2 : 4;
        }
      }

      function checkWin() {
        return grid.flat().includes(2048);
      }

      function checkGameOver() {
        for (let row = 0; row < GRID_SIZE; row++) {
          for (let col = 0; col < GRID_SIZE; col++) {
            if (grid[row][col] === 0) return false;
            if (col < GRID_SIZE - 1 && grid[row][col] === grid[row][col + 1]) return false;
            if (row < GRID_SIZE - 1 && grid[row][col] === grid[row + 1][col]) return false;
          }
        }
        return true;
      }

      function moveTiles(direction) {
        if (gameOver) return;
        let moved = false;
        const newGrid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        const merged = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));

        const loop = (row, col, dr, dc) => {
          while (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
            let r = row, c = col;
            while (true) {
              const nr = r + dr, nc = c + dc;
              if (nr < 0 || nr >= GRID_SIZE || nc < 0 || nc >= GRID_SIZE) break;
              if (grid[r][c] === 0) break;
              if (newGrid[nr][nc] === 0) {
                newGrid[nr][nc] = newGrid[r][c];
                newGrid[r][c] = 0;
                r = nr; c = nc;
                moved = true;
              } else if (newGrid[nr][nc] === newGrid[r][c] && !merged[nr][nc]) {
                newGrid[nr][nc] *= 2;
                score += newGrid[nr][nc];
                newGrid[r][c] = 0;
                merged[nr][nc] = true;
                moved = true;
                break;
              } else break;
            }
            row -= dr === 0 ? 0 : dr < 0 ? -1 : 1;
            col -= dc === 0 ? 0 : dc < 0 ? -1 : 1;
          }
        };

        // Copy original grid
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            newGrid[r][c] = grid[r][c];
          }
        }

        if (direction === "up") for (let c = 0; c < GRID_SIZE; c++) loop(1, c, -1, 0);
        if (direction === "down") for (let c = 0; c < GRID_SIZE; c++) loop(GRID_SIZE - 2, c, 1, 0);
        if (direction === "left") for (let r = 0; r < GRID_SIZE; r++) loop(r, 1, 0, -1);
        if (direction === "right") for (let r = 0; r < GRID_SIZE; r++) loop(r, GRID_SIZE - 2, 0, 1);

        if (moved) {
          grid = newGrid;
          addRandomTile();
          updateScore();
          renderGrid();
          if (checkWin()) alert("ðŸŽ‰ You win!");
          if (checkGameOver()) {
            gameOver = true;
            gameOverElement.classList.remove("hidden");
          }
        }
      }

      document.addEventListener("keydown", e => {
        if (e.key === "ArrowUp") moveTiles("up");
        if (e.key === "ArrowDown") moveTiles("down");
        if (e.key === "ArrowLeft") moveTiles("left");
        if (e.key === "ArrowRight") moveTiles("right");
      });

      newGameButton.addEventListener("click", initGame);
      tryAgainButton.addEventListener("click", initGame);

      // Touch support
      let startX, startY;
      gridElement.addEventListener("touchstart", e => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
      });
      gridElement.addEventListener("touchend", e => {
        const dx = e.changedTouches[0].clientX - startX;
        const dy = e.changedTouches[0].clientY - startY;
        if (Math.abs(dx) > Math.abs(dy)) {
          if (dx > 50) moveTiles("right");
          else if (dx < -50) moveTiles("left");
        } else {
          if (dy > 50) moveTiles("down");
          else if (dy < -50) moveTiles("up");
        }
      });

      initGame();
    });
  </script>
</body>
</html>
